{# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (c) 2023 - present Expiscor Group Inc.
#
# This file is part of Orion's Belt Project (https://github.com/IncudoLABS/orions-belt).
#
# Published by the IncudoLABS.
# Original author: Marko Sarunac <128757181+SaruWiz@users.noreply.github.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Template ID: OB-005-T
# Used by: OB-005
#}
#!/bin/bash

# Password policy enforcement script template
# This template is used by OB-005 (password_policies.yml) #}

# Password Policy Enforcement Script
# Generated by Ansible Security Hardening Playbook

set -e

LOG_FILE="/var/log/password_policy.log"
LOCK_FILE="/var/run/password_policy.lock"

# Create log file if it doesn't exist
touch "$LOG_FILE"

# Function to log messages
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Check if script is already running
if [ -f "$LOCK_FILE" ]; then
    PID=$(cat "$LOCK_FILE" 2>/dev/null)
    if kill -0 "$PID" 2>/dev/null; then
        log_message "Script already running (PID: $PID)"
        exit 1
    else
        rm -f "$LOCK_FILE"
    fi
fi

# Create lock file
echo $$ > "$LOCK_FILE"

# Cleanup function
cleanup() {
    rm -f "$LOCK_FILE"
    exit 0
}

trap cleanup EXIT INT TERM

log_message "Starting password policy enforcement"

# Check for expired passwords
log_message "Checking for expired passwords"
expired_users=$(chage -l root | grep "Password expires" | grep "password must be changed" | awk '{print $1}' || true)

if [ -n "$expired_users" ]; then
    log_message "Found expired passwords for users: $expired_users"
    # Send notification or take action
fi

# Check for inactive accounts
log_message "Checking for inactive accounts"
inactive_users=$(chage -l root | grep "Account expires" | grep "account has expired" | awk '{print $1}' || true)

if [ -n "$inactive_users" ]; then
    log_message "Found inactive accounts: $inactive_users"
    # Send notification or take action
fi

# Check for users with weak passwords (if pwquality is available)
if command -v pwcheck >/dev/null 2>&1; then
    log_message "Checking password quality"
    # This would require more complex implementation
    # pwcheck can be used to validate password quality
fi

# Check for users without password expiration
log_message "Checking password expiration settings"
no_expire_users=$(awk -F: '$2 != "*" && $2 != "!" && $2 != "!!" {print $1}' /etc/shadow | while read user; do
    max_days=$(chage -l "$user" 2>/dev/null | grep "Maximum number of days" | awk '{print $NF}')
    if [ "$max_days" = "99999" ] || [ "$max_days" = "-1" ]; then
        echo "$user"
    fi
done)

if [ -n "$no_expire_users" ]; then
    log_message "Found users without password expiration: $no_expire_users"
fi

# Check for root login attempts
log_message "Checking for root login attempts"
if [ -f /var/log/auth.log ]; then
    recent_root_attempts=$(grep "sshd.*root.*Failed password" /var/log/auth.log | tail -10 | wc -l)
    if [ "$recent_root_attempts" -gt 5 ]; then
        log_message "WARNING: Multiple root login attempts detected ($recent_root_attempts)"
    fi
fi

log_message "Password policy enforcement completed"

exit 0 